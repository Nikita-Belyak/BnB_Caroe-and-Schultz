"""
    branching(N::node, avg_x::Array{Float64}, variable_index::Int)
returns the child nodes generated from the parent node N where
avg_x is the vector of averaged values of the decision variables
generated by solving the dual problem and variable_index is the index
of the coordinate based on which child nodes are generated
"""
function branching(N::node, avg_x::Array{Float64}, variable_index::Int, strategy...)

    if strategy[1] == "int" # integer-based barcnhing
        # we use Float64() here to make sure that l\r_node_value stays Float
        # since child_node_generation() takes Float64 as the last parameter
        l_node_value = Float64(floor(Int64, avg_x[variable_index]))

        #print("l node value <= = $l_node_value\n ")

        r_node_value = Float64(l_node_value + 1)

        #print("r node value >= = $r_node_value\n ")
        l_node = child_node_generation(N, variable_index, "<=", l_node_value)
        r_node = child_node_generation(N, variable_index, ">=", r_node_value)
    else # non-anticipativity-based branching
        l_node_value = avg_x[variable_index] #- strategy[2]
        r_node_value = avg_x[variable_index] + strategy[2]
        l_node = child_node_generation(N, variable_index, "<=", l_node_value)
        r_node = child_node_generation(N, variable_index, ">=", r_node_value)

    end

    return l_node, r_node

end
